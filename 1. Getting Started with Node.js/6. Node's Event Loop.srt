1
00:00:00,000 --> 00:00:04,000
One of the key concepts "Node" brings from the browser to "JavaScript"

2
00:00:04,000 --> 00:00:08,000
on the server is the "Event Loop".

3
00:00:08,000 --> 00:00:12,000
In the browser, the "Event Loop" is constantly listening for DOM events,

4
00:00:12,000 --> 00:00:16,000
so just key presses or mouse clicks.

5
00:00:16,000 --> 00:00:23,000
Similarly, Node's "Event Loop" is constantly listening for events on the server side.

6
00:00:23,000 --> 00:00:31,000
These events can be externally generated, such as incoming HTTP requests or TCP connections,

7
00:00:31,000 --> 00:00:37,000
or they can be timers and other internal events generated by your "Node" application itself.

8
00:00:37,000 --> 00:00:41,000
Additionally, other events may be triggered on the response

9
00:00:41,000 --> 00:00:44,000
to a request against an external resource.

10
00:00:44,000 --> 00:00:51,000
For example, asking "Node" to open a file for reading will fire an event

11
00:00:51,000 --> 00:00:54,000
when the file is opened and ready.

12
00:00:54,000 --> 00:01:01,000
Sending a message to an external process will fire an event when the message has been sent.

13
00:01:01,000 --> 00:01:09,000
And making a request of a network resource, such as another web server, will fire an event

14
00:01:09,000 --> 00:01:12,000
when the HTTP response is received.

15
00:01:12,000 --> 00:01:17,000
A key point is that each of these are handled as discrete events in "Node".

16
00:01:17,000 --> 00:01:22,000
In fact, the events will very likely interleave each other.

17
00:01:22,000 --> 00:01:28,000
For example, in this diagram, a timer event is received between the request for a file

18
00:01:28,000 --> 00:01:32,000
and when the file is ready for reading, and both TCP

19
00:01:32,000 --> 00:01:38,000
and HTTP events are received while we're sending a message to an external process.

20
00:01:38,000 --> 00:01:43,000
"Node" itself doesn't pause and wait for any of these requests to complete.

21
00:01:43,000 --> 00:01:47,000
It simply continues to react to events as they arrive.

22
00:01:47,000 --> 00:01:52,000
A common example to demonstrate this non-blocking,

23
00:01:52,000 --> 00:01:59,000
event-driven approach is a web application that fetches data from a data base.

24
00:01:59,000 --> 00:02:04,000
The application raises an event when an HTTP request is received.

25
00:02:04,000 --> 00:02:09,000
This event generates a query to the data base for some information.

26
00:02:09,000 --> 00:02:15,000
Once "Node" receives an event back from the data base that the query is complete,

27
00:02:15,000 --> 00:02:20,000
an HTTP response is formulated and sent to the caller.

28
00:02:20,000 --> 00:02:25,000
While it is waiting for the response from the data base, however, "Node" is not blocked

29
00:02:25,000 --> 00:02:29,000
and is free to handle additional requests.

30
00:02:29,000 --> 00:02:34,000
Here you can see that it receives a second request while still waiting for the first one

31
00:02:34,000 --> 00:02:39,000
to complete, and so on, and so forth.

32
00:02:39,000 --> 00:02:43,000
This non-blocking approach is fundamental to "Node", and differentiates it

33
00:02:43,000 --> 00:02:46,000
from the more traditional, server-side programming model that requires you

34
00:02:46,000 --> 00:59:00,000
to manage multiple threads to achieve this type of concurrency.

